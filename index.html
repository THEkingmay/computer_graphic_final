<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>May3</title>
<style>
    body { margin: 0; overflow: hidden; background: #ffffff; }
    canvas { display: block; }
</style>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

<script>
let scene, camera, renderer, controls;
let moveToPosition = {
  camera: new THREE.Vector3(0, -3, 15),
  target: new THREE.Vector3(0, 0, 0)
};
let cameraMoving = true;

let clickableObj = [];
let cameraPosition = new THREE.Vector3(10, 20, 24);
let controlsPosition = new THREE.Vector3(0, 0, 0);

// ------------------ Scene / Camera / Renderer ------------------
function createScene() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
}

function createCamera() {
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.copy(cameraPosition);
}

function createRenderer() {
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
}

// ------------------ Light ------------------
function createLight() {
    const spot = new THREE.SpotLight(0xffffff, 1);
    spot.position.set(0, 0, 20);
    spot.angle = Math.PI / 6;
    spot.penumbra = 0.5;
    spot.decay = 2;
    spot.distance = 50;
    spot.castShadow = true;
    spot.shadow.mapSize.width = 2048;
    spot.shadow.mapSize.height = 2048;
    spot.shadow.bias = -0.0005;
    scene.add(spot);

    const ambient = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambient);
}

// ------------------ Controls ------------------
function createControls() {
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.minPolarAngle = Math.PI / 10;        
    controls.maxPolarAngle = Math.PI / 1.10;
    controls.minAzimuthAngle = -Math.PI / 3;
    controls.maxAzimuthAngle = Math.PI / 3;
    controls.enableDamping = true;
    controls.enableZoom = false;
    controls.enablePan = false;
}

// ------------------ Text ------------------
function createText() {
    const loader = new THREE.FontLoader();

    // "Welcome to my portfolio"
    loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', font => {
        const textGeo = new THREE.TextGeometry("Welcome to my portfolio", {
            font: font,
            size: 1,
            height: 0.2,
            curveSegments: 12,
        });
        textGeo.center();
        const textMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const textMesh = new THREE.Mesh(textGeo, textMat);
        textMesh.position.y = 1;
        textMesh.castShadow = true;
        scene.add(textMesh);
    });

    // "Get Started >" (Clickable)
    loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', font => {
        const startGeo = new THREE.TextGeometry("Get Started >", {
            font: font,
            size: 0.6,
            height: 0.1,
            curveSegments: 12,
        });
        startGeo.center();
        const startMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const startMesh = new THREE.Mesh(startGeo, startMat);
        startMesh.position.y = -1.5;
        startMesh.name = "getStarted";
        startMesh.castShadow = true;
        clickableObj.push(startMesh);
        scene.add(startMesh);
    });
}

// ------------------ Plane ------------------
function createPlane() {
    const mat = new THREE.MeshStandardMaterial({ color: 0x363636 });

    const frontGeo = new THREE.PlaneGeometry(40, 40);

    const frontPlane = new THREE.Mesh(frontGeo, mat);
    frontPlane.position.z = -5;
    frontPlane.receiveShadow = true;
    scene.add(frontPlane);

    const leftPlane = new THREE.Mesh(frontGeo, mat);
    leftPlane.position.x = -20;
    leftPlane.rotation.y = Math.PI / 2;
    leftPlane.receiveShadow = true;
    scene.add(leftPlane);

    const rightPlane = new THREE.Mesh(frontGeo, mat);
    rightPlane.position.x = 20;
    rightPlane.rotation.y = -Math.PI / 2;
    rightPlane.receiveShadow = true;
    scene.add(rightPlane);

    const bottomPlane = new THREE.Mesh(frontGeo, mat);
    bottomPlane.position.y = -20;
    bottomPlane.rotation.x = -Math.PI / 2;
    bottomPlane.receiveShadow = true;
    scene.add(bottomPlane);

    const topPlane = new THREE.Mesh(frontGeo, mat);
    topPlane.position.y = 20;
    topPlane.rotation.x = Math.PI / 2;
    topPlane.receiveShadow = true;
    scene.add(topPlane);
}

// ------------------ Resize ------------------
function handleResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
window.addEventListener('resize', handleResize);

// ------------------ Update Camera ------------------
function updateCamera() {
    if (!cameraMoving || !moveToPosition) return;

    camera.position.lerp(moveToPosition.camera, 0.05);
    controls.target.lerp(moveToPosition.target, 0.05);
    controls.update();

    if (camera.position.distanceTo(moveToPosition.camera) < 0.01 &&
        controls.target.distanceTo(moveToPosition.target) < 0.01) {
        camera.position.copy(moveToPosition.camera);
        controls.target.copy(moveToPosition.target);
        moveToPosition = null;
        cameraMoving = false;
    }
}

// ------------------ Raycaster ------------------
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function setPointer(e) {
    const r = renderer.domElement.getBoundingClientRect();
    const x = (e.clientX ?? e.touches[0].clientX) - r.left;
    const y = (e.clientY ?? e.touches[0].clientY) - r.top;
    pointer.x = (x / r.width) * 2 - 1;
    pointer.y = -(y / r.height) * 2 + 1;
}

function onPick(e) {
    setPointer(e);
    raycaster.setFromCamera(pointer, camera);
    const hit = raycaster.intersectObjects(clickableObj, true)[0]; // true รวม child
    if (!hit) return;

    if (hit.object.name === "getStarted") {
        cameraMoving = true;
        // กำหนดกล้องไปข้างหลังและสูงขึ้นจาก target
        moveToPosition = {
            camera: new THREE.Vector3(10, 10, 30),
            target: new THREE.Vector3(0, 0, 0)
        };
    }
}

renderer?.domElement.addEventListener('click', onPick);
renderer?.domElement.addEventListener('touchend', (e) => { onPick(e); });

// ------------------ Animate ------------------
function animate() {
    requestAnimationFrame(animate);
    updateCamera();
    controls.update();
    renderer.render(scene, camera);
}

// ------------------ Main ------------------
function main() {
    createScene();
    createCamera();
    createRenderer();
    createLight();
    createControls();
    createPlane();
    createText();

    animate();
}

main();
</script>
</body>
</html>
